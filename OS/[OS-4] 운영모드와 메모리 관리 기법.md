#OS-4 운영모드와 메모리 관리 기법

x86와 x86-64 프로세스에서 지원하는 메모리 관리 기법은 크게 2가지이다.<br>

* 세그먼테이션(Segmentation)
* 페이징(Paging)

둘다 모두 메모리를 나누는 것이고 차이점은 세그먼테이션은 원하는크기로 짤라 쓰는 방식이고, 페이징 같은경우에는 정해진 크기로 짤라져 있는 조각을 모아 원하는 크기로 관리하는 방식이다.<br>

*세그먼테이션*은 세그먼트의 시작주소 or 디스크립터라고 불리는 자료구조의 위치를 설정 해야된다.

*페이징*은 CR3 레지스터에 페이지 디렉터리라 불리는 자료구조의 물리주소를 설정해야지 사용 가능하다.

###리얼 모드의 메모리 관리 방식

최대 1MB까지 주소공간을 사용하며, 세그먼테이션만 지원한다.
세그먼트 크기는 64k로 고정이며, 세그먼트 시작 주소는 코드나 메모리에 접근할 때 기준 어드레스로 사용된다.

#####물리주소 계산법
	(세그먼트 레지스터) * 16 + (범용 레지스터) = (물리주소)

세그먼트 레지스터에 16를 곱하여 범용레지스터를 더하게 되면, 최대 1MB주소까지 접근 가능하게 된다.


###보호 모드의 메모리 관리 방식

보호 모드는 **세그먼테이션**과 **페이징**을 모두 지원한다.<br>
리얼모드의 **세그먼테이션**보다 많은 기능을 제공합니다.<br> 
세그먼트 레지스터에 세그먼트의 기준 주소를 직접 설정하는 대신 디스크럽터 자료구조의 위치를 설정하는 방식으로 변경 되었다.<br>
세그먼트 레지스터 명칭도 **세그먼트 셀렉터**로 변경 되었다.

세그먼트에 대한 정보를 나타내는 디스크럽터를 *세그먼트 디스크럽터*라고 한다.

세그먼트 디스크럽터에는 시작어드레스,크기,권한,타입 등의 정보가 있다.

![Imgur](http://i.imgur.com/Ge2UUBnm.png)

DPL(Descriptor Privilege Level)은 해당 세그먼트에 접근하기 위한 최소한의 권한을 나타내며, 0~3 사이 값을 가진다. 숫자가 작을수록 권한이 높다.<br>
세그먼트에 접근할때 CPL(Current Privilege Level)이 적어도 디스크럽터에 설정된 권한과 같거나 높아야(낮아야) 된다. 안그러면 예외 처리 된다.

세그먼트 디스크립터는 GDT(Global Descriptor Table)라고 불리는 곳에 모여 있다. GDT는 연속된 디스크럽터의 집합이고, 최대 812개의 디스크럽터를 포함 할 수 있는 테이블 형태의 자료구조 이다.

GDT도 메모리상에 위치하는 자료구조라서 프로세서가 GDT 위치를 직접 알려줘야된다. GDT 위치관련 레지스터는 *GDTR* 이다. 

GDTR는 16bit GDT 크기 필드와 32bit 기준주소 필드로 구성된 자료구조의 물리 주소를 넘겨 받는다. 프로세서는 이값을 저장했다가 세그먼트 셀렉터를 통해 어드레스 접근시  GDT의 위치를 찾는데 참조한다.

#####물리주소 계산법
	(세그먼트 레지스터) * 16 + (범용 레지스터) = (물리주소)
	
**기준주소+범용레지스터 > 세그먼트의 크기**일 경우 프로세서는 세그먼트의 접근 권한을 위반한 경우와 마찬가지로 예외 처리로 오류가 발생한다.

페이징을 사용하지 않으면 선형주소는 물리주소와 1:1 대응한다.<br>
보통 사용하더라도 1:1로 대응하도록 설정한다.

#####선형주소와 물리주소가 1:1대응 할때 이점

 - OS메모리관리 기능을 작고 가볍게 유지가능하다.
 - 메모리 구조가 직관적이라 디버깅이 편하다.


####페이징

물리메모리를 페이지라고 불리는 일정한 크기로 나눠 선형주소와 물리주소를 페이지로 연결하는 방식이다.<br>

**장점**

-	물리메모리 크기보다 더 큰영역의 선형주소도 물리페이지만 연결하면 사용 가능하여 주소공간을 더 넓게 사용 가능.
-  여러 선형주소에 연결함으로써, 응용프로그램끼리 공유하는 메모리를 손쉽게 처리 가능.

<br>
보호모드에서 페이징은 페이지 크기에 따라 두 가지 방식이다.<br>
단계만 다를뿐 둘다 기본 원리는 같다.

-	물리메모리를 4KB로 나누고 선형주소를 3단계로 구분
-  물리메모리를 4MB로 나누고 선형주소를 2단계로 구분

3단계 페이징은 선형주소를 디렉터리,테이블,오프셋 세부분으로 나누고 메모리를 4kb로 나누어 관리하는 방식이다.

![Imgur](http://i.imgur.com/XEj2KNmm.jpg)

디렉터리와 테이블 부분은 페이지 디렉터리와 페이지 테이블에 있는 엔트리의 위치를 나타낸다.
GDT와 마찬 가지로 메모리에 있는 자료구조일뿐이라 프로세서가 페이징 처리 과정에서 해당 테이블을 사용 할려면, **CR3**를 이용해야된다.

CR3는 페이지 디렉터리 시작주소를 가리키며 페이지 디렉터리 엔트리의 위치 계산에서 사용된다.

페이지 (디렉터리,테이블) 엔트리는 크기가 모두 4바이트이다.
12bit~31bit는 기준주소를 나타내며, 11bit~0bit는 속성 필드로 사용 된다.

![Imgur](http://i.imgur.com/YuVLGObm.png)

U/S : 페이지 접근 할 수 있는 권한을 나타낸다.<br>
U/S가 0일때 유저 애플리케이션 레벨(3)을 제외한 모든 레벨 접근 가능하다.<br>
U/S가 1일때 모든 레벨에서 접근이 가능하다.

페이지와 세그먼테이션의 보호기능으로 커널영역과 유저영역을 구분 할 수 있다.


#####물리주소 계산
	(페이지의 시작주소) + (선형 주소의 페이지 오프셋) = (물리주소)
<br>
**물리주소 구하는과정**

-	CR3에 설정된 주소로 페이지 디렉터리의 시작주소를 찾는다.
-	페이지 디렉터리의 시작주소에 선형주소의 디렉터리 오프셋을 이용해 해당 디렉터리 엔트리를 찾는다. (해당 디렉터리 엔트리 설정값이  페이지 테이블의 시작 주소)
-	페이지 테이블의 시작주소에 선형주소의 테이블 오프셋을 이용해 해당 테이블 엔트리를 찾는다. (해당 테이블 엔트리 설정값이 4KB 페이지의 시작 주소)
-	(페이지의 시작주소) + (선형 주소의 페이지 오프셋) = (물리주소)
<br>


<br>
###IA-32e 모드의 메모리 관리

서브모드,호환모드,64비트 모드가 존재한다.<br>
서브모드와 호환모드는 보호모드와 동작이 같다.<br>
그래서 여기서는 64비트 모드에 대해서만 설명합니다. 

IA-32e모드에서 메모리관리 기법은 기본적인 부분은 같으며, 페이징이 필수이다..<br>
세그먼테이션은 주소공간이 확장되고 두가지 서브모드를 지원하는 등 기능 확장이 되었다.

**세그먼테이션 차이점**

-	세그먼트 디스크럽터에 설정된 기준주소와 크기에 관계없이 기준주소는 0, 크기는 64bit 전체로 설정된다.
-	호환모드와 64비트 모드의 두가지 서브모드를 지원하여 이걸 구분하고자 세그먼트 디스크럽터에 L 필드(21bit)가 추가 됬다. (L=0 호환모드/L=1 64비트 모드)

64비트 모드에서는 주소 공간이 64비트로 늘어나서 PAE 기능이 기본으로 활성화 된다.<br>
4KB 페이지는 5단계, 4MB 페이지는 4단계로 변경되었다. 

페이지 맵 레벨 4 테이블(PML4)과 페이지 디렉터리 포인터 테이블(PDPT)가 추가 되었다.
보호모드 페이징과 별 다를게 없다. 


#####IA-32e 5단계 페이징과 물리주소 변환 과정

![Imgur](http://i.imgur.com/C0E6m7Qm.png)

-	CR3(PML4) + PML4 오프셋 = PML4 엔트리
-  디렉터리 포인터 기준주소 + 디렉터리 포인터 오프셋 = 디렉터리 포인트 엔트리
-  페이지 디렉터리 기준주소 + 테이블 오프셋 = 페이지 테이블 엔트리
-  4KB 페이지 기준주소 + 오프셋 = 물리주소
<br><br>

![Imgur](http://i.imgur.com/ZTmMCexm.png)

IA-32e 모드의 페이지 엔트리는 8바이트로 늘어났다.<br>
하위4바이트는 보호모드와 구조가 같으며, 상위4바이트는 기준주소+예약된 영역+임의로 사용가능한 영역, EXB로 구성된다.

EXB 필드는 해당 페이지에서 명령어가 실행되는것을 막는 필드이다.
EXB 속성을 활성화하면, 명령어가 실행되는 순간 페이지 폴트 예외가 발생하여 프로그램이 중단된다. (bof)

